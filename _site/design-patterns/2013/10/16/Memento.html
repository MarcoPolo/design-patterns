<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Memento</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Design Patterns</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Memento</h2>
<p class="meta">16 Oct 2013</p>

<div class="post">
<h1 id="toc_0">Initial Comment</h1>

<p>An object may have a lot of state - how much of that stat actually needs to be captured
depends upon the application&#39;s needs </p>

<h1 id="toc_1">Structure ...</h1>

<h1 id="toc_2">Mechanism</h1>

<p>In java, It&#39;s particulary easy to safely implement Memento
* define an empty interface <code>Memento</code>
* Whenever an <code>Originator</code> is asked to create a <code>Memento</code>, it&#39;ll construct and return an
  instalnce of an object that implemnts that interface (in an <code>Originator</code> specific wat). 
* the class implementing <code>Memento</code> can be a private member of the  `Originator class.  </p>

<h1 id="toc_3">Implemntation issues</h1>

<p>As with <code>Prototype</code>,  one must decide hwther a deep copy is
necessary or a shallow copy will suffice . </p>

<p>if one is creating a lot of Memontos ( or even just a few of a prticularly heavy
 <code>Originator</code>) it may take a great deal of memory to hold them.</p>

<hr>

<p>The memory reqs can be mitigated by having the <code>Mementos</code> store just <em>incremental</em> changes
- i.e., the sutff that has been odified since the last <strong>Memento</strong> was created.</p>

<p>In java, it&#39;s pariculary easy to <em>safely</em> implement <code>Memento</code></p>

<ul>
<li>e.g. with a bitmap (image), preserve the affected region ( rather than the entire image)
then we can restore the image to its original state by just repainting the affected
region with the preserved data</li>
</ul>

<p>A <code>Memento</code> may save the <code>Originator</code>&#39;s</p>

<ul>
<li>entire state</li>
<li>a sub-set of its state</li>
<li>just the recently changed aspects</li>
</ul>

<h1 id="toc_4">Example in Java</h1>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Class Originator {
    private int a;
    String[] s;

    private class OriginatorMemento implemnts Memento {
        int aCopy;
        String[] sCopy;

        OriginatorMemento(){
            aCopy = a;
            sCopy = s; //might want to duplicate array

            void restore ( Originator anOriginator ) {
                if (anOriginator != Originator.this ) {
                    throw new Exception(&quot;Bad!&quot;);
                }

                a = aCopy;
                s = sCopy;
            }
        }

        public Memento makeMemento() {
            return new OriginatorMemento();
        }

        public void restore(Memento m) {
            ((OriginatorMemento) m).restore(this);
        }
    }
}
</code></pre></div>
<p>Java note: had we not passed a reference to this in the call to Memento&#39;s restore, the
memento created by a different originator could be used to create a brain transplat.</p>

<h1 id="toc_5">Cursor</h1>

<p>This is an <em>alternatiive</em> to the Iterator pattern. </p>

<p>Note: the cursor is not capturing any of th ecreated objects&#39;s state, but rather a state
of traversal over that object&#39;s elements.</p>

<h1 id="toc_6">Example in Java</h1>
<div class="highlight"><pre><code class="text language-text" data-lang="text">interface Cursor { 
}

class Gizmo {
    private Widget[] widget;

    private class GizmoCursor implemnts Cursor {
        int i = 0;
    }

    public Cursor makeCursor(){
        return new GizmoCursor();
    }

    public void first ( Cursor c){
        ((GizmoCursor) c).i &lt; widget.length;
    }

    public Widget currentElement( Cursor c ){
        return widget[ ((GizmoCursor) c).i ];
    }

    public void next( Cursor c ) {
        ++((GizmoCursor) c).i;
    }

    //other gizmo operations elided
    }
}
</code></pre></div>
<h1 id="toc_7">Observation</h1>

<p>The Gizmo class defines an interface that permits multiple simultaneous traversals across
its elements: the state of each traversal is maintained in an <em>independent</em> <code>Cursor</code>
object.</p>

<h1 id="toc_8">Adminsitrivia more than .5 done :(</h1>

<ul>
<li>Semester more than 1/2 done :(</li>
<li>HW Mebbe</li>
</ul>

<h1 id="toc_9">Memento (283)</h1>

<h1 id="toc_10">Mementos &amp; Transactions</h1>

<p>A <em>transaction</em> is a set of operations, <em>all</em> of which must be completed in order for any
of them to take effect. <strong>Memento</strong> will give us the ability to...</p>

<ul>
<li>roll-back steps prior to the transaction being committed</li>
<li>undo previously applied operations</li>
</ul>

<h1 id="toc_11">Canonical way of performaing a transaction</h1>

<p>1) make a Memento
2) perform operawtion(s) on the Originator
3) <em>validate</em> the <strong>Originator</strong>
4) if the <strong>Originator&#39;s</strong> state is inconsitent, restore the prior state from the memento</p>

<h1 id="toc_12">Griffin&#39;s &quot;What if?&quot; protocol</h1>

<p>This is an <em>alternative</em> to using <strong>Memnto</strong> that is based on <code>Prototype</code> 
1) clone the Originator [ the <code>Prototype</code> ]
2) perform operation(s) on the clone
3) <em>validate</em> the clone.
4) if inconsistent, throw an exception<br>
    * note: the    <code>Originator</code>/<code>Prototype</code> is <em>unchanged</em>
    else repeat the operations on the <code>Originator/Prototype</code></p>

<p>Con: Operations must be perfformed thice (when successful)<br>
con: some operations &quot;consume resources&quot; and thus performing the twice is going to have
unintended consequences:</p>

<p>Pro: originator is <em>never</em> in an inconsistent statee<br>
pro: object identity is goin to be preserved  [object&#39;s identity wouldn&#39;t be preserved had
we decided (after a successful step 3) to simply replace the Originator with the clone]:
especially important when objects are persisted in a database.</p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
