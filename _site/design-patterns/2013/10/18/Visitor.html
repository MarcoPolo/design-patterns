<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Visitor</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">Design Patterns</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>Visitor</h2>
<p class="meta">18 Oct 2013</p>

<div class="post">
<h1 id="toc_0">HW</h1>

<p>Online</p>

<h1 id="toc_1">Intent</h1>

<p>Represent an operation to be performed on the elements of an object structure. Visitor
lets you define a new operation without chaning the classes of elements on which it
operates.</p>

<h1 id="toc_2">Initial Comments</h1>

<ul>
<li>The object strucuter is (usually) composed of heterogenous types<br>

<ul>
<li>each of the different types will execute a different method when the <code>Visitor</code>&#39;s
operation is invoked.<br></li>
</ul></li>
<li>The patterns is not limited to just performing an operation on the elements of an object
structure. It can also be used with<br>

<ul>
<li>Independent obejcts [ie., one not grouped into a structure]<br></li>
<li>multiple structures<br></li>
<li>can be used with strucutre that are not typically related</li>
</ul></li>
</ul>

<h1 id="toc_3">A bit of programming history</h1>

<p>Assume we have a set of <em>Shapes</em> that we want to display...</p>

<h1 id="toc_4">Procedural solution</h1>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for each Shape s
    switch ( s )
        case SQUARE: drawSquare();
        case CIRCLE: drawCircle();
        ...
</code></pre></div>
<p>Conditional login is used to determine what kind of thing to draw, and having identified
it, to draw.</p>

<h1 id="toc_5">Object-oriented solution</h1>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for each Shape s
    s.draw();
</code></pre></div>
<p>Each kind of <em>Shape</em> must know how to draw itself
* conditional logic has been eliminated
* knowledge about how a particular shape is draw is encapsulated in that Shape</p>

<h1 id="toc_6">FP</h1>
<div class="highlight"><pre><code class="text language-text" data-lang="text">(map draw shapes)
</code></pre></div>
<h1 id="toc_7">Visitor-oriented solution</h1>

<p>Visitor V = new ShapePrintingVisistor();
for each Shape s
    s.accept(v);</p>

<p>the Visitor is the thing that knows <em>how</em> to draw shapes. <em>Shapes</em> do <em>not</em> know how to
draw themselves.  </p>

<ul>
<li>conditional logic is eliminated</li>
<li>drawing logic is localised in the <code>Visitor</code></li>
</ul>

<h1 id="toc_8">A &quot;first glance&quot; critique</h1>

<p>visitor centralizes the location where variations on an operation are stored.  </p>

<ul>
<li>Appears to be a major encapsulation violation</li>
<li>rather than each Shape having its own draw(), all the variations are defined in a single
<code>Visitor</code> class.</li>
</ul>

<h1 id="toc_9">Double dispatch</h1>

<p>You&#39;ve been weand on programming in OO environments that support <em>single dispatch</em>   </p>

<ul>
<li>the method that gets executed when an operation is invoked on an object depends on that
(taget) object&#39;s class (_dynamic binding_)<br></li>
</ul>

<p>with double dispatch the method that (ultimately) get executed depends on the <code>class</code> of
two objects: inour example here:   </p>

<ul>
<li>the object upon which the oepration was invoked, and </li>
<li>the object that was supplied as an argument</li>
</ul>

<p>Note: the act of drawing will almost certainly require the <code>Visitor</code>  ( specifically the
<code>ShapeDrawingVisitor</code>) to query the Shape for geometric data - e.g. radius. but that has
been elided from the SD above.</p>

<p>In this case, <em>double dispatch</em> is implemented by the (concrete) Shape&#39;s accept() method, 
which tells the <code>ShapeVisitor</code> which of its visitX() it should execute.</p>

<h1 id="toc_10">Applicability</h1>

<ul>
<li>the set of classes which are candidtaes for being visisted must be relatively static<br>

<ul>
<li>reason : every time a new class is added to the set of visitable classes, the
Visitor interface must be updated, and hence all the classes which implement it must
be updated to support the operations that visit that class</li>
</ul></li>
<li>often, it&#39;s not until late in a product&#39;s life-cycle that one recognizes, &quot;Hey we should
have used the visitor pattern!&quot;</li>
<li><p>e.g., creating a complete Shape hieracrchy only to realize that one needs to be able to
draw them - thus requiring us to revise each of the calsses so that it&#39;ll support a
draw()</p></li>
<li><p>had the Visitor pattern been used from the start, because alll we&#39;d need to do is
implemnt an appororiate Visitor</p></li>
<li><p>When is Visitor violating encapsulation? when is it supporting encapsulation?  </p></li>
<li><p>a class&#39;s interface should support only those operations that are essential to that
class&#39;s core abstraction.</p></li>
<li><p>Tangentially related operations are not part of the core abstraction.</p></li>
<li><p>thus we can argue that lumping all the variations (across a hierarchy) of a non-core
operation into a Visitor is actually supporting good encapsulation.</p></li>
</ul>

<h1 id="toc_11">Who controls the traversal?</h1>

<ul>
<li>Something external to the visitor<br>

<ul>
<li>that thing would be responsible for calling <code>accept()</code> on sucessive elemtns of the
strucutre bein visited<br></li>
<li>pro: can support multiple (simultaneous) traversals<br></li>
<li>pro: can have finer grained control over the traversals<br></li>
</ul></li>
<li>Visitor itself

<ul>
<li>Traversal code isn&#39;t easily reusable when it&#39;s encapsulated in the visitor</li>
<li>but... what if it uses an Iterator? then something that is reusable but also have
the control in the visitor</li>
</ul></li>
</ul>

<h1 id="toc_12">What does a Visitor do during a traversal?</h1>

<p>There are many possibilities; among them...<br>
* Modify (some of) the visited objects<br>
* accumumlate state based upon the attributes of
  the visited objects<br>
* construct an object structure based on the visited objects</p>

<h1 id="toc_13">Define the Visitor interface</h1>

<p>...</p>

<h1 id="toc_14">Define the Visitor Class(es)</h1>

<p>...</p>

</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Your Name<br />
                  What You Are<br />
                  your@email.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/yourusername/">github.com/yourusername</a><br />
                  <a href="http://twitter.com/yourusername/">twitter.com/yourusername</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
